     1                                  ; A boot sector that boots a C kernel in 32 - bit protected mode
     2                                  [org 0x7c00]
     3                                  KERNEL_OFFSET equ 0x1000
     4 00000000 8816[EB00]              mov [BOOT_DRIVE], dl	; BIOS stores our boot drive in DL , so it 's
     5                                  			; best to remember this for later
     6                                  
     7 00000004 BD0090                  mov bp, 0x9000		; Set-up the stack.
     8 00000007 89EC                    mov sp, bp
     9                                  
    10 00000009 BB[EC00]                mov bx, MSG_REAL_MODE
    11 0000000C E80800                  call print_string_abs
    12                                  
    13 0000000F E8B500                  call load_kernel
    14 00000012 E84600                  call switch_to_pm
    15                                  
    16 00000015 EBFE                    jmp $			; Hang
    17                                  
    18                                  ; Include our useful , hard - earned routines
    19                                  %include "routines/print_string_abs.asm"
    20                              <1> print_string_abs:
    21 00000017 60                  <1> 	pusha	;push all registers to be polite
    22                              <1> 	
    23 00000018 B40E                <1> 	mov ah, 0x0e	;BIOS tele - type output
    24                              <1> 
    25                              <1> 	;add bx,0x7c00	;boot sector is loaded at 0x7c00 address
    26                              <1> 			;therefore 0x7c00 needs to be added to the data address
    27                              <1> 			;to get the correct absolute data address
    28                              <1> 	
    29                              <1> print_next_byte_abs:
    30 0000001A 268A07              <1> 	mov al,[es:bx]	;bx is used as function parameter
    31 0000001D 3C00                <1> 	cmp al,0x00
    32 0000001F 7405                <1> 	je null_terminated_abs
    33 00000021 CD10                <1> 	int 0x10
    34 00000023 43                  <1> 	inc bx
    35 00000024 EBF4                <1> 	jmp print_next_byte_abs
    36                              <1> 	
    37                              <1> null_terminated_abs:
    38 00000026 B00A                <1> 	mov al,0x0a	;new line character
    39 00000028 CD10                <1> 	int 0x10	;print a new line
    40 0000002A 61                  <1> 	popa	;pop all registers to be polite
    41 0000002B C3                  <1> 	ret	;pop return address and jump to it
    42                                  %include "routines/disk_load_callee.asm"
    43                              <1> disk_load:
    44 0000002C 60                  <1>  pusha
    45                              <1> 
    46 0000002D 52                  <1>  push dx		; Store  DX on  stack  so  later  we can  recall
    47                              <1> 			; how  many  sectors  were  request  to be read ,
    48                              <1> 			; even if it is  altered  in the  meantime
    49                              <1>  
    50 0000002E 88F0                <1>  mov al, dh		; DX is input, DH stores how many sectors to read
    51                              <1> 
    52 00000030 B402                <1>  mov ah, 0x02		; BIOS read sector function
    53                              <1> 
    54                              <1> ; mov dl, 0x00		; first floppy drive
    55                              <1> 			; DL stores boot_drive, set by the caller
    56                              <1> 
    57                              <1> ; DL is already set by the caller as BOOT_DRIVE
    58                              <1> 
    59                              <1> ; mov ch, 0x03		; select cylinder 3
    60                              <1> 
    61 00000032 B500                <1>  mov ch, 0x00		; cylinder 0
    62                              <1> 
    63                              <1> ; mov dh, 0x01		; Select the track on 2nd side of floppy
    64                              <1> 			; disk , since this count has a base of 0
    65                              <1> 
    66 00000034 B600                <1>  mov dh, 0x00		; Select head 0
    67                              <1> 
    68                              <1> ; mov cl, 0x04		; Select  the 4th  sector  on the  track  - not
    69                              <1> 			; the 5th , since  this  has a base of 1.
    70                              <1> 
    71 00000036 B102                <1>  mov cl, 0x02		; Start  reading  from  second  sector (i.e.
    72                              <1> 			; after  the  boot  sector)
    73                              <1> 
    74                              <1> ; BX is already set by the caller as the destination address
    75                              <1> 
    76 00000038 CD13                <1>  int 0x13
    77 0000003A 7207                <1>  jc disk_error
    78                              <1> 
    79 0000003C 5A                  <1>  pop dx
    80 0000003D 38C6                <1>  cmp dh, al		; if AL (sectors read) != DH (sectors expected)
    81 0000003F 7502                <1>  jne disk_error
    82                              <1>  
    83 00000041 61                  <1>  popa
    84 00000042 C3                  <1>  ret
    85                              <1> 
    86                              <1>  disk_error:
    87 00000043 BB[4B00]            <1>  	mov bx, DISK_ERROR_MSG
    88 00000046 E8CEFF              <1>  	call print_string_abs
    89 00000049 EBFE                <1> 	jmp $		; jump forever to the same line
    90                              <1> 
    91                              <1>  DISK_ERROR_MSG:
    92 0000004B 4469736B2072656164- <1>  	db 'Disk read error',0x00
    93 00000054 206572726F7200      <1>
    94                                  %include "routines/switch_to_pm.asm"
    95                              <1> [bits 16]
    96                              <1> ;switch to protected mode
    97                              <1> 
    98                              <1> switch_to_pm:
    99                              <1> 
   100 0000005B FA                  <1>  cli 	; We must switch of interrupts until we have
   101                              <1> 	; set -up the protected mode interrupt vector
   102                              <1> 	; otherwise interrupts will run riot.
   103                              <1> 
   104 0000005C 0F0116[A200]        <1>  lgdt [gdt_descriptor]	; Load our global descriptor table , which defines
   105                              <1> 			; the protected mode segments ( e.g. for code and data )
   106                              <1> 
   107 00000061 0F20C0              <1>  mov eax, cr0
   108 00000064 6683C801            <1>  or eax, 0x00000001
   109 00000068 0F22C0              <1>  mov cr0, eax		; To make the switch to protected mode , we set
   110                              <1> 			; the first bit of CR0 , a control register
   111                              <1> 
   112 0000006B EA[7000]0800        <1>  jmp CODE_SEG:init_pm	; Make a far jump ( i.e. to a new segment ) to our 32 - bit
   113                              <1> 			; code. This also forces the CPU to flush its cache of
   114                              <1> 			; pre - fetched and real - mode decoded instructions , which can
   115                              <1> 			; cause problems.
   116                              <1> 
   117                              <1>  [bits 32]
   118                              <1> 
   119                              <1>  init_pm:
   120                              <1>   ; Initialise registers and the stack once in PM.
   121 00000070 66B81000            <1>   mov ax, DATA_SEG
   122 00000074 8ED8                <1>   mov ds, ax
   123 00000076 8ED0                <1>   mov ss, ax
   124 00000078 8EC0                <1>   mov es, ax
   125 0000007A 8EE0                <1>   mov fs, ax
   126 0000007C 8EE8                <1>   mov gs, ax
   127                              <1> 
   128 0000007E BD00000900          <1>   mov ebp, 0x00090000
   129 00000083 89EC                <1>   mov esp, ebp
   130                              <1> 
   131 00000085 E850000000          <1>   call BEGIN_PM
   132                                  %include "routines/gdt.asm"
   133                              <1> gdt_start:
   134                              <1> 
   135                              <1> gdt_null:
   136 0000008A 00000000            <1>  dd 0x00000000
   137 0000008E 00000000            <1>  dd 0x00000000
   138                              <1> 
   139                              <1> gdt_code:	;the code segment descriptor
   140                              <1>  ; base =0x0 , limit =0 xfffff ,
   141                              <1>  ; 1st flags : ( present )1 ( privilege )00 ( descriptor type )1 -> 1001 b
   142                              <1>  ; type flags : ( code )1 ( conforming )0 ( readable )1 ( accessed )0 -> 1010 b
   143                              <1>  ; 2nd flags : ( granularity )1 (32 - bit default )1 (64 - bit seg )0 ( AVL )0 -> 1100 b
   144 00000092 FFFF                <1>  dw 0xffff	;limit=0xffff (bit 0 to 15)
   145 00000094 0000                <1>  dw 0x0000	;base=0x0000 (bit 16 to 31)
   146 00000096 00                  <1>  db 0x00	;base=0x00 (bit 0 to 7) (start the second 32-bit)
   147 00000097 9A                  <1>  db 0b10011010	;present=1 privilege=00 descriptor-type=1 code=1 conforming=0 readable=1 accessed=0
   148 00000098 CF                  <1>  db 0b11001111	;granularity=1 32-bit-default=1 64-bit=0 available=0 limit=0xf=0b1111 (bit 16 to 19)
   149 00000099 00                  <1>  db 0x00	;base=0x00 (bit 24 to 31)
   150                              <1> 
   151                              <1> gdt_data:	;the data segment descriptor
   152                              <1>  ; Same as code segment except for the type flags :
   153                              <1>  ; type flags : ( code )0 ( expand down )0 ( writable )1 ( accessed )0 -> 0010 b
   154 0000009A FFFF                <1>  dw 0xffff      ;limit=0xffff (bit 0 to 15)
   155 0000009C 0000                <1>  dw 0x0000      ;base=0x0000 (bit 16 to 31)
   156 0000009E 00                  <1>  db 0x00        ;base=0x00 (bit 0 to 7) (start the second 32-bit)
   157 0000009F 92                  <1>  db 0b10010010  ;present=1 privilege=00 descriptor-type=1 code=0 expand-down=0 writable=1 accessed=0
   158 000000A0 CF                  <1>  db 0b11001111  ;granularity=1 32-bit-default=1 64-bit=0 available=0 limit=0xf=0b1111 (bit 16 to 19)
   159 000000A1 00                  <1>  db 0x00        ;base=0x00 (bit 24 to 31)
   160                              <1> 
   161                              <1> gdt_end:
   162                              <1>  ; The reason for putting a label at the end of the
   163                              <1>  ; GDT is so we can have the assembler calculate
   164                              <1>  ; the size of the GDT for the GDT decriptor ( below )
   165                              <1> 
   166                              <1> ;GDT descriptor
   167                              <1> gdt_descriptor:
   168 000000A2 1700                <1>  dw gdt_end - gdt_start -1 	; Size of our GDT , always less one
   169                              <1> 				; of the true size
   170                              <1> 				; should be 3*8-byte=24-byte: 0d24=0x0018 ?
   171                              <1> 				; should be 0x0018-1=0x0017
   172 000000A4 [8A000000]          <1>  dd gdt_start
   173                              <1> 
   174                              <1> ; Define some handy constants for the GDT segment descriptor offsets , which
   175                              <1> ; are what segment registers must contain when in protected mode. For example ,
   176                              <1> ; when we set DS = 0 x10 in PM , the CPU knows that we mean it to use the
   177                              <1> ; segment described at offset 0 x10 ( i.e. 16 bytes ) in our GDT , which in our
   178                              <1> ; case is the DATA segment (0 x0 -> NULL ; 0x08 -> CODE ; 0 x10 -> DATA )
   179                              <1> CODE_SEG equ gdt_code - gdt_start ; shoule be 0x08 ?
   180                              <1> DATA_SEG equ gdt_data - gdt_start ; should be 0x10 ?
   181                                  %include "routines/print_string_pm.asm"
   182                              <1> [bits 32]
   183                              <1> ;Define some constants
   184                              <1> VIDEO_MEMORY equ 0x000b8000
   185                              <1> WHITE_ON_BLACK equ 0x0000000f
   186                              <1> 
   187                              <1> ; prints a null - terminated string pointed to by EBX
   188                              <1> print_string_pm:
   189 000000A8 60                  <1>  pusha
   190                              <1>  
   191 000000A9 BA00800B00          <1>  mov edx, VIDEO_MEMORY ; Set edx to the start of vid mem.
   192 000000AE 81C2800C0000        <1>  add edx, 0d3200	;0xb8000 + 2 * (row * 80 + col)
   193                              <1> 			;row=20, col=0 => VIDEO_MEMORY+0d3200
   194                              <1> 			;Video Graphics Array (VGA) colour text mode with dimmensions 80x25 characters
   195                              <1>  
   196                              <1>  print_string_pm_loop:
   197                              <1>   
   198 000000B4 8A03                <1>   mov al, [ebx]
   199 000000B6 B40F                <1>   mov ah, WHITE_ON_BLACK
   200                              <1>   
   201 000000B8 3C00                <1>   cmp al, 0x00
   202 000000BA 7409                <1>   je print_string_pm_done	; if (al == 0) , at end of string , so
   203                              <1> 				; jump to done
   204                              <1>   
   205 000000BC 668902              <1>   mov [edx], ax 	; Store char and attributes at current
   206                              <1> 			; character cell.
   207                              <1> 
   208 000000BF 43                  <1>   inc ebx		; Increment EBX to the next char in string.
   209 000000C0 83C202              <1>   add edx, 0x02		; Move to next character cell in vid mem.
   210 000000C3 EBEF                <1>   jmp print_string_pm_loop
   211                              <1> 
   212                              <1> print_string_pm_done:
   213 000000C5 61                  <1>  popa
   214 000000C6 C3                  <1>  ret
   215                                  
   216                                  [bits 16]
   217                                  
   218                                  load_kernel:
   219 000000C7 BB[0D01]                 mov bx, MSG_LOAD_KERNEL
   220 000000CA E84AFF                   call print_string_abs
   221                                  
   222 000000CD BB0010                   mov bx, KERNEL_OFFSET	; Set-up parameters for our disk_load routine
   223 000000D0 B60F                     mov dh, 15		; we load the first 15 sectors ( excluding the boot sector ) from the boot disk ( i.e. our kernel code ) to address KERNEL_OFFSET in memory
   224 000000D2 8A16[EB00]               mov dl, [BOOT_DRIVE]
   225 000000D6 E853FF                   call disk_load
   226                                  
   227 000000D9 C3                       ret
   228                                  
   229                                  [bits 32]
   230                                  ; This is where we arrive after switching to and initialising protected mode.
   231                                  BEGIN_PM:
   232 000000DA BB[2C010000]             mov ebx, MSG_PROT_MODE
   233 000000DF E8C4FFFFFF               call print_string_pm
   234                                  
   235 000000E4 E8(00100000)             call KERNEL_OFFSET
   236                                  
   237 000000E9 EBFE                     jmp $			; Hang
   238                                  
   239                                  ; Global variables
   240 000000EB 00                      BOOT_DRIVE: db 0x00
   241 000000EC 5374617274696E6720-     MSG_REAL_MODE: db "Starting in 16-bit real mode ...",0x00
   242 000000F5 696E2031362D626974-
   243 000000FE 207265616C206D6F64-
   244 00000107 65202E2E2E00       
   245 0000010D 4C6F6164696E67206B-     MSG_LOAD_KERNEL: db "Loading kernel into memory ...",0x00
   246 00000116 65726E656C20696E74-
   247 0000011F 6F206D656D6F727920-
   248 00000128 2E2E2E00           
   249 0000012C 4C616E646564206F6E-     MSG_PROT_MODE: db "Landed on 32-bit protected mode without any error!",0x00
   250 00000135 2033322D6269742070-
   251 0000013E 726F74656374656420-
   252 00000147 6D6F64652077697468-
   253 00000150 6F757420616E792065-
   254 00000159 72726F722100       
   255                                  
   256                                  ; Bootsector padding
   257 0000015F 00<rept>                times 510-($-$$) db 0x00
   258 000001FE 55AA                    dw 0xaa55
