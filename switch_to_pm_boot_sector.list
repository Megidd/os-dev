     1                                  ; A boot sector that enters 32 - bit protected mode.
     2 00000000 BD0090                  mov bp, 0x9000
     3 00000003 89EC                    mov sp, bp
     4                                  
     5 00000005 BB[A000]                mov bx, MSG_REAL_MODE
     6 00000008 E80500                  call print_string
     7                                  
     8 0000000B E85700                  call switch_to_pm	; Note that we never return from here,
     9                                  			; because it will jump to BEGIN_PM
    10                                  
    11 0000000E EBFE                    jmp $
    12                                  
    13                                  %include "print_string_callee.asm"
    14                              <1> print_string:
    15 00000010 60                  <1> 	pusha	;push all registers to be polite
    16                              <1> 	
    17 00000011 B40E                <1> 	mov ah, 0x0e	;BIOS tele - type output
    18                              <1> 
    19 00000013 81C3007C            <1> 	add bx,0x7c00	;boot sector is loaded at 0x7c00 address
    20                              <1> 			;therefore 0x7c00 needs to be added to the data address
    21                              <1> 			;to get the correct absolute data address
    22                              <1> 	
    23                              <1> print_next_byte:
    24 00000017 8A07                <1> 	mov al,[bx]	;bx is used as function parameter
    25 00000019 3C00                <1> 	cmp al,0x00
    26 0000001B 7405                <1> 	je null_terminated
    27 0000001D CD10                <1> 	int 0x10
    28 0000001F 43                  <1> 	inc bx
    29 00000020 EBF5                <1> 	jmp print_next_byte
    30                              <1> 	
    31                              <1> null_terminated:
    32 00000022 B00A                <1> 	mov al,0x0a	;new line character
    33 00000024 CD10                <1> 	int 0x10	;print a new line
    34 00000026 61                  <1> 	popa	;pop all registers to be polite
    35 00000027 C3                  <1> 	ret	;pop return address and jump to it
    36                                  %include "gdt.asm"
    37                              <1> gdt_start:
    38                              <1> 
    39                              <1> gdt_null:
    40 00000028 00000000            <1>  dd 0x00000000
    41 0000002C 00000000            <1>  dd 0x00000000
    42                              <1> 
    43                              <1> gdt_code:	;the code segment descriptor
    44                              <1>  ; base =0x0 , limit =0 xfffff ,
    45                              <1>  ; 1st flags : ( present )1 ( privilege )00 ( descriptor type )1 -> 1001 b
    46                              <1>  ; type flags : ( code )1 ( conforming )0 ( readable )1 ( accessed )0 -> 1010 b
    47                              <1>  ; 2nd flags : ( granularity )1 (32 - bit default )1 (64 - bit seg )0 ( AVL )0 -> 1100 b
    48 00000030 FFFF                <1>  dw 0xffff	;limit=0xffff (bit 0 to 15)
    49 00000032 0000                <1>  dw 0x0000	;base=0x0000 (bit 16 to 31)
    50 00000034 00                  <1>  db 0x00	;base=0x00 (bit 0 to 7) (start the second 32-bit)
    51 00000035 9A                  <1>  db 0b10011010	;present=1 privilege=00 descriptor-type=1 code=1 conforming=0 readable=1 accessed=0
    52 00000036 CF                  <1>  db 0b11001111	;granularity=1 32-bit-default=1 64-bit=0 available=0 limit=0xf=0b1111 (bit 16 to 19)
    53 00000037 00                  <1>  db 0x00	;base=0x00 (bit 24 to 31)
    54                              <1> 
    55                              <1> gdt_data:	;the data segment descriptor
    56                              <1>  ; Same as code segment except for the type flags :
    57                              <1>  ; type flags : ( code )0 ( expand down )0 ( writable )1 ( accessed )0 -> 0010 b
    58 00000038 FFFF                <1>  dw 0xffff      ;limit=0xffff (bit 0 to 15)
    59 0000003A 0000                <1>  dw 0x0000      ;base=0x0000 (bit 16 to 31)
    60 0000003C 00                  <1>  db 0x00        ;base=0x00 (bit 0 to 7) (start the second 32-bit)
    61 0000003D 92                  <1>  db 0b10010010  ;present=1 privilege=00 descriptor-type=1 code=0 expand-down=0 writable=1 accessed=0
    62 0000003E CF                  <1>  db 0b11001111  ;granularity=1 32-bit-default=1 64-bit=0 available=0 limit=0xf=0b1111 (bit 16 to 19)
    63 0000003F 00                  <1>  db 0x00        ;base=0x00 (bit 24 to 31)
    64                              <1> 
    65                              <1> gdt_end:
    66                              <1>  ; The reason for putting a label at the end of the
    67                              <1>  ; GDT is so we can have the assembler calculate
    68                              <1>  ; the size of the GDT for the GDT decriptor ( below )
    69                              <1> 
    70                              <1> ;GDT descriptor
    71                              <1> gdt_descriptor:
    72 00000040 1700                <1>  dw gdt_end - gdt_start -1 	; Size of our GDT , always less one
    73                              <1> 				; of the true size
    74                              <1> 				; should be 3*8-byte=24-byte: 0d24=0x0018 ?
    75                              <1> 				; should be 0x0018-1=0x0017
    76 00000042 [28000000]          <1>  dd gdt_start
    77                              <1> 
    78                              <1> ; Define some handy constants for the GDT segment descriptor offsets , which
    79                              <1> ; are what segment registers must contain when in protected mode. For example ,
    80                              <1> ; when we set DS = 0 x10 in PM , the CPU knows that we mean it to use the
    81                              <1> ; segment described at offset 0 x10 ( i.e. 16 bytes ) in our GDT , which in our
    82                              <1> ; case is the DATA segment (0 x0 -> NULL ; 0x08 -> CODE ; 0 x10 -> DATA )
    83                              <1> CODE_SEG equ gdt_code - gdt_start ; shoule be 0x08 ?
    84                              <1> DATA_SEG equ gdt_data - gdt_start ; should be 0x10 ?
    85                                  %include "print_string_pm.asm"
    86                              <1> [bits 32]
    87                              <1> ;Define some constants
    88                              <1> VIDEO_MEMORY equ 0x000b8000
    89                              <1> WHITE_ON_BLACK equ 0x0000000f
    90                              <1> 
    91                              <1> ; prints a null - terminated string pointed to by EBX
    92                              <1> print_string_pm:
    93 00000046 60                  <1>  pusha
    94                              <1>  
    95 00000047 BA00800B00          <1>  mov edx, VIDEO_MEMORY ; Set edx to the start of vid mem.
    96 0000004C 81C2800C0000        <1>  add edx, 0d3200	;0xb8000 + 2 * (row * 80 + col)
    97                              <1> 			;row=20, col=0 => VIDEO_MEMORY+0d3200
    98                              <1> 			;Video Graphics Array (VGA) colour text mode with dimmensions 80x25 characters
    99                              <1>  
   100                              <1>  print_string_pm_loop:
   101                              <1>   
   102 00000052 8A03                <1>   mov al, [ebx]
   103 00000054 B40F                <1>   mov ah, WHITE_ON_BLACK
   104                              <1>   
   105 00000056 3C00                <1>   cmp al, 0x00
   106 00000058 7409                <1>   je print_string_pm_done	; if (al == 0) , at end of string , so
   107                              <1> 				; jump to done
   108                              <1>   
   109 0000005A 668902              <1>   mov [edx], ax 	; Store char and attributes at current
   110                              <1> 			; character cell.
   111                              <1> 
   112 0000005D 43                  <1>   inc ebx		; Increment EBX to the next char in string.
   113 0000005E 83C202              <1>   add edx, 0x02		; Move to next character cell in vid mem.
   114 00000061 EBEF                <1>   jmp print_string_pm_loop
   115                              <1> 
   116                              <1> print_string_pm_done:
   117 00000063 61                  <1>  popa
   118 00000064 C3                  <1>  ret
   119                                  %include "switch_to_pm.asm"
   120                              <1> [bits 16]
   121                              <1> ;switch to protected mode
   122                              <1> 
   123                              <1> switch_to_pm:
   124                              <1> 
   125 00000065 FA                  <1>  cli 	; We must switch of interrupts until we have
   126                              <1> 	; set -up the protected mode interrupt vector
   127                              <1> 	; otherwise interrupts will run riot.
   128                              <1> 
   129 00000066 0F0116[4000]        <1>  lgdt [gdt_descriptor]	; Load our global descriptor table , which defines
   130                              <1> 			; the protected mode segments ( e.g. for code and data )
   131                              <1> 
   132 0000006B 0F20C0              <1>  mov eax, cr0
   133 0000006E 6683C801            <1>  or eax, 0x00000001
   134 00000072 0F22C0              <1>  mov cr0, eax		; To make the switch to protected mode , we set
   135                              <1> 			; the first bit of CR0 , a control register
   136                              <1> 
   137 00000075 EA[7A00]0800        <1>  jmp CODE_SEG:init_pm	; Make a far jump ( i.e. to a new segment ) to our 32 - bit
   138                              <1> 			; code. This also forces the CPU to flush its cache of
   139                              <1> 			; pre - fetched and real - mode decoded instructions , which can
   140                              <1> 			; cause problems.
   141                              <1> 
   142                              <1>  [bits 32]
   143                              <1> 
   144                              <1>  init_pm:
   145                              <1>   ; Initialise registers and the stack once in PM.
   146 0000007A 66B81000            <1>   mov ax, DATA_SEG
   147 0000007E 8ED8                <1>   mov ds, ax
   148 00000080 8ED0                <1>   mov ss, ax
   149 00000082 8EC0                <1>   mov es, ax
   150 00000084 8EE0                <1>   mov fs, ax
   151 00000086 8EE8                <1>   mov gs, ax
   152                              <1> 
   153 00000088 BD00000900          <1>   mov ebp, 0x00090000
   154 0000008D 89EC                <1>   mov esp, ebp
   155                              <1> 
   156 0000008F E800000000          <1>   call BEGIN_PM
   157                                  
   158                                  [bits 32]
   159                                  BEGIN_PM:
   160                                   ; This is where we arrive after switching to and initialising protected mode.
   161 00000094 BB[C1000000]             mov ebx, MSG_PROT_MODE
   162 00000099 E8A8FFFFFF               call print_string_pm	; Use our 32 - bit print routine.
   163                                  
   164 0000009E EBFE                     jmp $
   165                                  
   166 000000A0 5374617274696E6720-     MSG_REAL_MODE db "Starting in 16-bit real mode ...",0x00
   167 000000A9 696E2031362D626974-
   168 000000B2 207265616C206D6F64-
   169 000000BB 65202E2E2E00       
   170 000000C1 4C616E64656420696E-     MSG_PROT_MODE db "Landed in 32-bit protected mode!",0x00
   171 000000CA 2033322D6269742070-
   172 000000D3 726F74656374656420-
   173 000000DC 6D6F64652100       
   174                                  
   175 000000E2 00<rept>                times 510-($-$$) db 0x00
   176 000001FE 55AA                    dw 0xaa55
